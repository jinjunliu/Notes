---
title: "Big O notation"
date: 2022-01-27
draft: false
weight: 42
---

## Introduction

Big O notation is a mathematical notation for describing the complexity of an algorithm. Time and space complexity are two things we care about when it comes to designing algorithms.

## Worst Case

{{< katex >}}\Omega(n){{< /katex >}} is the best case complexity of an algorithm. {{< katex >}}\theta(n){{< /katex >}} is the average case complexity of an algorithm. {{< katex >}}\Omicron(n){{< /katex >}} is the worst case complexity of an algorithm.

## {{< katex >}}\Omicron(n){{< /katex >}}

The time complexity of the following code is {{< katex >}}\Omicron(n){{< /katex >}}.

```python
def print_items(n):
    for i in range(n):
        print(i)

print_items(10)
```

## Drop Constant

The constant can be dropped from the expression. For example, {{< katex >}}\Omicron(2n){{< /katex >}} can be rewritten as {{< katex >}}\Omicron(n){{< /katex >}}.

```python
def print_items(n):
    for i in range(n):
        print(i)

    for j in range(n):
        print(j)

print_items(10)
```

## {{< katex >}}\Omicron(n^2){{< /katex >}}

The time complexity of the following code is {{< katex >}}\Omicron(n^2){{< /katex >}}.

```python
def print_items(n):
    for i in range(n):
        for j in range(n):
            print(i,j) 

print_items(10)
```

The following code runs for {{< katex >}}\Omicron(n^3){{< /katex >}} time.

```python
def print_items(n):
    for i in range(n):
        for j in range(n):
            for k in range(n):
                print(i,j,k)

print_items(10)
```

{{< katex >}}\Omicron(n^3){{< /katex >}} (and so on) can be simplified to {{< katex >}}\Omicron(n^2){{< /katex >}}.

## Drop non-dominants

The time complexity of the following code is {{< katex >}}\Omicron(n^2+n){{< /katex >}}.

```python
def print_items(n):
    for i in range(n):
        for j in range(n):
            print(i,j)
    for k in range(n):
        print(k)

print_items(10)
```

We can drop the non-dominant term n, therefore the time complexity is {{< katex >}}\Omicron(n^2){{< /katex >}}.

## O(1)

{{< katex >}}\Omicron(1){{< /katex >}} means the time complexity is constant, i.e., no matter how large the input size is, the time complexity is always the same.

```python
def add_items(n):
    return n + n + n

print add_items(10)
```

## {{< katex >}}\Omicron(\log n){{< /katex >}}

Binary search is an example of an algorithm that has time complexity of {{< katex >}}\Omicron(\log n){{< /katex >}}.

## Different Terms for Inputs

```python
def print_items(a,b):
    for i in range(a):
        print(i)

    for j in range(b):
        print(j)

print_items(1, 10)
```

The above function has two parameters, a and b, and the time complexity is {{< katex >}}\Omicron(a+b){{< /katex >}}. It can not be simplified to {{< katex >}}\Omicron(a){{< /katex >}} or {{< katex >}}\Omicron(b){{< /katex >}}.

## Lists

* {{< katex >}}\Omicron(1){{< /katex >}}: my_list.append(item), my_list.pop(), my_list.lookup(index)
* {{< katex >}}\Omicron(n){{< /katex >}}: my_list.pop(n), my_list.insert(n, item), my_list.remove(item), my_list.lookup(item) (because the list needs to be reindexed)

## Wrap up

Please refer to [this cheat sheet](https://www.bigocheatsheet.com/) for more details.