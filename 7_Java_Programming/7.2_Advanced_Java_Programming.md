---
title: "Advanced Java Programming"
date: 2022-04-15
draft: true
weight: 802
---


## Introduction to Advanced Java Programming Techniques

Introduction of this course.

### Prerequisites

* Using basic programming constructs like variables, functions, conditionals, and loops.
* Creating and using primitive types like booleans, ints, and doubles.
* Creating and using common data types like Strings, * Exceptions, enums, and arrays.
* Creating and working with standard collections like Lists, Sets, and Maps.
* Designing your own classes and interfaces.
* Familiar with OOP concepts like objects, classes, inheritance, and polymorphism.

### Introduction to Advanced Java Programming Techniques

What are "Advanced" Java Programming Techniques?

* Functional Programming
* Multi-threading
* Dynamic Coding Techniques
* Dependency Injection
* AOP: Aspect Oriented Programming

The following chart shows a brief history of the development of the Java programming language.

![A Brief History of the Java Programming Language](/images/A_Brief_History_of_Java.png)

### Stakeholders

Who Does Software Design Affect?

* Software Developers
* Managers
* End Users

### Course outline

1. Functional Programming in Java
2. Working with Files and I/O
3. Design Patterns
4. Reflection
5. Introduction to Concurrent Programming

![Advanced Java Outline](/images/advanced_java_outline.png)

### Tools, Environment, & Dependencies

* IntelliJ IDEA
* JDK 10+

### Project: Parallel Web Crawler

Here's some info about the project you will complete at the end of the course.

UdaciSearch is interested in figuring out popular search terms on the internet in order to improve the SEO of their clients.

You are given the source code for your company's legacy web crawler, which is single-threaded. You notice it's a bit slow, and you quickly realize a way to improve its performance and impress your new manager.

## Functional Programming in Java

Here are some topics covered in this lesson:

- Comparing and contrasting imperative and functional programming styles, and understanding when one style might be preferrable over the other.
- Using functional interfaces and lambdas to create shorter, easier-to-read Java code.
- Using the Stream API to process data and aggregate the results into Java collections.

### Big Picture & Intuition

**Imperative Code**

Early Java programs were usually programmed in the imperative style. Imperative code usually focuses on how a task is performed. Each line of code gives a specific procedure or operation:

```java
int getTopScore(List<Student> students) {
 int topScore = 0;
 for (Student s : students) {
   if (s == null) continue;
   topScore = Math.max(topScore, s.getScore());
 }
 return topScore;
}
```

- Focuses on how a task is performed.
- Each line of code gives a specific procedure or operation.

**Question 1/2**

Which of these are elements of imperative programs? (A, C)

- `for` loops and `while` loops
- lambda expressions
- Individual steps about how a task is performed
- Streams

**Functional Code**

Starting with version 8, Java added language features to support a more functional style of programming. You might also hear some people call it declarative programming.

Functional code focuses on what happens to inputs in order to produce outputs. You can think of it as describing how to get from the input to the output:

```java
int getTopScore(List<Student> students) {
 return students.stream()
     .filter(Objects::nonNull)
     .mapToInt(Student::getScore)
     .max()
     .orElse(0);
}
```

This code does the exact same thing as the last code example, but it uses a more functional programming style, because it:

- Focuses on what happens to inputs in order to produce outputs..
- Describes how to transform the input into the output.

**Question 2/2**

Which of these are elements of functional programming in Java? (A, B, C)

- Lambda expressions
- Streams
- step-by-step transformation of what ishappenning to inputs
- `for` loops and `while` loops

**Functional vs Imperative Code**

- There is nothing wrong with either imperative or functional styles of programming.
- Anything you can do with one, you can do with the other.
- Whether to use one or the other often boils down to your specific scenario, and your personal preference as a programmer.

### Using Lambda Expressions

**Lambda Expressions**

`Lambdas` are a Java language feature that make it very easy to implement certain kinds of interfaces in Java. When you compare lambda expressions to the traditional way to of implementing a Java interface, lambdas usually result in much cleaner and easier to understand code.

**Code demo**

```java
import java.util.List;
import java.util.function.Predicate;

public final class LambdasMain {

  /**
   * Returns the number of strings that match a given condition.
   *
   * @param input the strings that should be tested.
   * @param condition the condition that strings should be tested against.
   * @return the number of strings in the input that match the condition.
   */
  public static long countMatchingStrings(List<String> input, Predicate<String> condition) {
    return input.stream().filter(condition).count();
  }

  public static void main(String[] args) {

    List<String> input = List.of("hello", "\t   ", "world", "", "\t", " ", "goodbye", "  ");

    long numberOfWhitespaceStrings =
            countMatchingStrings(input, s -> s.trim().isEmpty());

    System.out.println(numberOfWhitespaceStrings + " whitespace strings");
  }
}
```

```java
BinaryOperator<Integer> add =
   (Integer a, Integer b) -> { return a + b; };

System.out.println(add.apply(1, 2));
```

As you saw from the demo, you can use lambdas to greatly shorten you code and make it easier to read.

**Question 1/2**

Which parts of the lambda expression syntax are optional? (A, B, D, E)

- The `return` statement
- The parameter types
- The `->` arrow
- The `(...)` parentheses (when there is justone parameter)
- The `{}` curly braces, for single-statement lambdas

**Question 2/2**

Which of the following are valid lambda expressions? (A, B, C, D)

- (Double x, int y) -> { return x * y; }
- (x, y) -> x * y
- x -> x * x
- () -> () -> 10
- {x, y} -> (x + y)
- (Double x, Double y) -> {x * y}


{{< hint info >}}
Java can infer the parameter types.

If the right side of the lambda is a result of a one-liner operation the curly braces can be removed.

If there's only one argument on the left side of the lambda, the parentheses are optional.

When there are no arguments on the left side of the lambda expression we can use a pair of empty parentheses `()`. Lambdas are also allowed to return other lambdas.

When using curly braces to delimit a block of code on the right side of the lambda, the `return` keyword is required.

Curly braces cannot be used on the left side of the lambda.

{{< /hint >}}

**Key Terms**

- `Lambda expression`: An expression that can be used to succinctly implement certain interfaces in Java.

### Functional Interfaces

In this section, you will learn to:

- Define what lambda functions and functional interfaces are.
- Identify when lambda functions and functional interfaces can be used.

**Functional Interfaces**

In the previous section, I mentioned that only certain kinds of interfaces can be implemented by lambdas. Those interfaces are called `functional interfaces`.

A functional interface is a Java interface with exactly one abstract method, called the functional method.

**Example**

```java
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
  default Predicate<T> negate() { return (t) -> !test(t); }

  // Other methods left out of this example
}
```

The `Predicate` interface from the demo you saw earlier was a functional interface.

Notice that functional interfaces are Java interfaces, and just like a non-functional Java interface, they are allowed to have type parameters. Here, Predicate has one type parameter T, which is the type being tested.

`Predicate`'s one abstract method is `test()`. `test()` is known as the functional method. "Abstract" means the method is not implemented, so in order to be a functional method, it cannot have a default implementation. However, functional interfaces *can* have other default methods. In this case, the `Predicate` interface has a default method called `negate()` that returns another `Predicate`.

The `@FunctionalInterface` annotation at the top serves two important purposes:

- If that annotation is added to any interface that is not a valid functional interface, the Java compiler will report a compilation error.
- It tells whoever is reading the code that this is interface is designed to be used with lambdas.

That's why if you intend for an interface to be functional, you should always add the `@FunctionalInterface` annotation.

When you're designing a Java interface, you should consider making it a functional interface if it describes a single operation.

**Quiz Question**

Which of these statements are true? (A, C, D)

- A functional interface is an interface with exactly one abstract method.
- A functional interface is an abstract class with several abstract methods.
- A functional interface can be inplemented by a lambda expression.
- The `@FunctionalInterface` annotation can help detect errors.

### Quizzes: Functional Interfaces

**QUESTION 1 OF 6**

Why should you use the `@FunctionalInterface` annotation when writing your own functional interfaces? (A, C)

- It will cause a compilation error if the annotated interface is not a valid functional interface.
- The Java compiler requires functional interfaces to have that annotation.
- It tells users of your interface that the interface is intended to be targeted by lambdas.
- It allows the Java runtime to optimize lambdas that implement the functional interface. 

{{< hint info >}}
Right! @FunctionalInterface signals that the interface can be targeted by lambdas, and it also causes the Java compiler to make sure it's actually a valid functional interface.
{{< /hint >}}

```java
@FunctionalInterface
public interface Function<T, R> {
    static <T> Function<T, T> identity() {
        return t -> t;
    }

    R apply(T t);

    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }
}
```

**QUESTION 2 OF 6**

What is the functional method of the `Function` interface above? (B)

- identity
- apply
- compose
- andThen

{{< hint info >}}
Correct! apply is the only abstract method in the Function interface.
{{< /hint >}}


```java
abstract class Printable {
  abstract void print(String prefix);
}
```

**QUESTION 3 OF 6**

Is `Printable` a functional interface? (No)

{{< hint info >}}
Right! `Printable` is not a functional interface because it is a class.
{{< /hint >}}

```java
interface Squareable {
  default int square(int a) {
    return a * a;
  }
}
```

**QUESTION 4 OF 6**

Is `Squareable` a functional interface? (No)

{{< hint info >}}
Correct! Functional interfaces must have exactly one abstract method. If a method has a `default` implementation, it's not abstract.
{{< /hint >}}

```java
public interface BiFunction<T, U, R> {
  R apply(T t, U u);
}
```

**QUESTION 5 OF 6**

Is `BiFunction` a functional interface? (Yes)

{{< hint info >}}

Correct! Functional interfaces are allowed to have type parameters, and the function method (`apply` in this case) can take any number of parameters.

{{< /hint >}}

```java
interface ConvertibleToString {
  @Override
  String toString();
}
```

**QUESTION 6 OF 6**

Is `ConvertibleToString` a functional interface? (No)

{{< hint info >}}
Right, remember that `java.lang.Object` methods, such as `toString()`, `equals()`, and `hashCode()` are not allowed to be the functional method.
{{< /hint >}}


### Exercise: defining a functional interface

**Binary Operations**

In this exercise, you will define a functional interface that represents a binary operation between two integers.

> **Binary operation** is a fancy term that refers to a method that takes two arguments.

In this case, your functional method should take two `int` arguments, and it should return an `int` result.

1. First, create an interface called BinaryOperation and put it in its own file. The interface should contain one abstract method, `apply()`, which takes two `int` arguments and returns an `int`.

2. Next, annotate the interface with `@FunctionalInterface`. If you structured the functional interface correctly, the Java compiler will allow it.

3. Then, make sure `Main.java` compiles:

```bash
javac Main.java
```

If you chose a name other than "BinaryOperation" for the functional interface, you will have to edit the code in the `main()` method to refer to your functional interface.

4. Finally, run the program:

```bash
java -ea Main
```

*Note:* The `-ea` flag stands for "enable assertions". It's useful here because `Main.java` has an `assert` statement in it.

### Solution: Defining a functional interface

**BinaryOperation.java**

```java
@FunctionalInterface
public interface BinaryOperation {
  int apply(int a, int b);
}
```

**Main.java**

```java
public final class Main {
  public static void main(String[] args) {
    BinaryOperation add = (a, b) -> a + b;
    // Or you could use:
    //
    //  BinaryOperation add = Integer::sum;
    //
    // More on method references later!

    assert 5 == add.apply(2, 3);
  }
}
```

**Alternative Solution**

If you were paying really close attention, you may have noticed you can avoid creating a custom functional interface altogether — just use `java.util.function.BinaryOperator` with a type parameter of `Integer`! Then your `Main.java` method would look like this:

```java
public final class Main {
  public static void main(String[] args) {
    BinaryOperator<Integer> add = (a, b) -> a + b;
    assert 5 == add.apply(2, 3);
  }
}
```

Take a moment to look at some of the other predefined functional interfaces in Java's built-in `java.util.function` package. It might save you some work in the future!


### Anonymous Subclasses

**What is an Anonymous Class?**

An anonymous class is a class that is defined "in-line" and has no name, and so it is called "anonymous".

Nowadays, many anonymous classes can be replaced by lambdas, but there are still some important differences you should know about:

**Anonymous Class vs. Lambda**

This anonymous class...

```java
Predicate<String> anonymousSubclass =
   new Predicate<String>() {
     @Override
     public boolean test(String s) {
       return s.trim().isEmpty();
     }
   };
```

... does the same thing as this lambda expresssion:

```java
Predicate<String> lambdaInstead = s -> s.trim().isEmpty();
```

| **Anonymous Class** | **Lambda** |
| ------------------- | --------- |
| Class generated at compile-time	| Class generated at run-time |
| Can override `equals()`/`hashCode()`	| Cannot override them; has no identity |
| `this` refers to the anonymous class | `this` refers to the enclosing class |

**What's `this` all about?**

Let's take a closer look at that last row in the table. `this` inside an anonymous class refers to the anonymous class, whereas `this` inside a lambda refers to the enclosing class. What does that mean exactly?

Consider this example:

```java
public final class ThisExample {
  private final Runnable withLambda =
      () -> System.out.println("From lambda: " + this.getClass());
  private final Runnable withSubclass = new Runnable() {
    @Override
    public void run() {
      System.out.println("From subclass: " + this.getClass());
    }
  };

  public static void main(String[] args) {
    ThisExample thisExample = new ThisExample();
    thisExample.withLambda.run();
    thisExample.withSubclass.run();
  }
}
```

What do you think this program prints?

Here's what it printed on my PC:

```
From lambda: class com.udacitydemo.lambdas.ThisExample
From subclass: class com.udacitydemo.lambdas.ThisExample$1
```

Inside the lambda, `this.getClass()` returns the class object representing `ThisExample`. We'll cover class objects in more detail in the lesson on reflection, but for now the important part is that the `this` keyword inside the lambda references the enclosing class, which is `com.udacitydemo.lambdas.ThisExample`.

For the `Runnable` subclass, on the other hand, the program printed `com.udacitydemo.lambdas.ThisExample$1`. You can see that the Java compiler generated a class called `com.udacitydemo.lambdas.ThisExample$1` for the anonymous lambda (yes, the class name contains a dollar sign), and the `this` keyword refers to *that* generated class! If you compile this program yourself, you'll even notice the Java compiler produces a file called `ThisExample$1.class`, which contains the compiled byte code for the anonymous class.

**Question 1 OF 2**

Which of these statements are true for anonymous classes? (B, C)

- Shorter code that can be dedined in-line
- The class is generated at compile-time
- Can override the `equals()` and `hashCode()` methods
- `this` refers to the enclosing class

**Question 2 OF 2**

What does the following program print? (E)

```java
public final class Main {
  public static void main(String[] args) {
    Runnable r = () -> System.out.println(this.getClass());
    r.run();
  }
}
```

- `Main`
- `class Main`
- `class Mian$1`
- `null`
- The program does not compile.

{{< hint info >}}
Right, this program actually does not compile! It was a little bit of a trick question — sorry about that!

Inside a lambda, the `this` keyword only means anything if there is an enclosing class. In this code, the lambda is defined inside a static function, so there `_is_` no enclosing class.

{{< /hint >}}


### Limitation of Lambdas

**Shortcomings of Lambdas**

Lambdas are very useful, but they do have some shortcomings:

- They can only be used to implement functional interfaces, not classes.
- Lambdas cannot implement any interface that has multiple abstract methods.
- Lambdas cannot throw checked exceptions (any subclass of `Exception`, such as `IOException`).
Code from the Demo

**Code from the Demo**

You can handle checked exceptions with a `try-catch` inside the lambda:

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

public final class ReadFilesMain {
  public static void main(String[] args) throws IOException {
    List<String> fileNames = Arrays.asList("file-a.txt", "file-b.txt", "file-c.txt");

    fileNames.stream()
        .map(Path::of)
        .map(p -> {
          try {
            return Files.readAllLines(p, StandardCharsets.UTF_8)
          } catch (IOException e) {
            return List.of();
          }
        })
        .flatMap(List::stream)
        .forEach(System.out::println);
  }
}
```

... or with a `for` loop:

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.stream.Stream;

public final class ReadFilesMain {
    public static void main(String[] args) throws IOException {
        List<String> fileNames = Arrays.asList("file-a.txt", "file-b.txt", "file-c.txt");

        for (String fileName : fileNames) {
            for (String line : Files.readAllLines(Paths.get(fileName), StandardCharsets.UTF_8)) {
                System.out.println(line);
            }
        }
    }
}
```

### Exercise: Lambdas

**Calculator**

In this exercise, you will build on your last exercise to make a simple, general-purpose calculator program that can be run from the command-line to perform math on two integer operands

> In case you need to brush up on the jargon: in the expression `1 + 2`, `+` is known as the ***operator***, and `1` and `2` are known as the ***operands***).

The `Calculator` API should roughly look like this:

```java
Calculator calculator = new Calculator();
calculator.registerOperation("+", (a, b) -> a + b);
assert 5 == calculator.calculate(2, "+", 3);
```

The main file, `Calculate.java` has already been partially filled in to parse the `int` operands and the `String` operator from the command-line arguments. Your task is to:

1. Fill in the `Calculator` class, which has been left completely empty in the starter code; and
2. Modify the `main()` method in `Calculate.java` to register the four "basic" binary operations:
  - Addition (represented by the "+" symbol)
  - Subtraction (represented by the "-" symbol)
  - Multiplication (represented by the "*" symbol)
  - Division (represented by the "/" symbol)

The `Calculator` class should maintain a mapping of operator symbols, such as "+", to operations. The operations will be represented by lambdas (see the code example above) that target a certain *Functional Interface*. We saw this in the previous code snippet:

```java
calculator.registerOperation("+", (a, b) -> a + b);
```

If you need a reminder about what built-in functional interface you can use for this part, reread the solution page for the previous exercise.

After you have finished, you should be able to use the `Calculate` program like this:

```
javac Calculate.java
java Calculate 3 + 4
7
java Calculate 48 / 8
6
```

### Solution: Lambdas

**Calculator.java**

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.BinaryOperator;

public final class Calculator {
  private final Map<String, BinaryOperator<Integer>> operators = new HashMap<>();

  public void registerOperation(String symbol, BinaryOperator<Integer> operator) {
    operators.put(symbol.strip(), operator);
  }

  public int calculate(int a, String operator, int b) {
    return operators.get(operator).apply(a, b);
  }
}
```

**Calculate.java**

```java
public final class Calculate {
  public static void main(String[] args) {
    if (args.length != 3) {
      System.out.println("Usage: Calculate [int] [operator] [int]");
      return;
    }

    Calculator calculator = new Calculator();
    calculator.registerOperation("+", (a, b) -> a + b);
    calculator.registerOperation("-", (a, b) -> a - b);
    calculator.registerOperation("/", (a, b) -> a / b);
    calculator.registerOperation("*", (a, b) -> a * b);

    int a = Integer.parseInt(args[0]);
    String operator = args[1];
    int b = Integer.parseInt(args[2]);

    System.out.println(calculator.calculate(a, operator, b));
  }
}
```

More about the Calculator:

Obviously, real-world calculators are a lot more robust. For starters, they are able to operate on more than two operands at a time, and therefore they have to handle the order of operations (for example: `3 + 12 / 5 * ( 4 - 2)`). However, even the most feature-rich calculators have a mapping somewhere that defines what the operators are, and what symbols are used to represent those operators. Today, you demonstrated how to accomplish that succinctly with Java lambdas.

By the way, this little program uses a design pattern known as the Strategy Pattern: the calculator employs a different operation "strategy" depending on which operation symbol is parsed from the command-line argument. You'll learn more about the strategy pattern in the lesson on design patterns.

### Edge Case: Capturing Variables

{{< youtube tXp_JJZrphI >}}

**Captured Variables**

Lambdas can capture variables from the surrounding code. If a lambda uses any variables from the surrounding code, those variables are captured. Variables can only be captured if they are effectively final.

An effectively final variable is a variable whose value does not change after it is initialized.

**Example**

```java
Map<Year, Integer> getClassSizes(List<Student> students) {
  final Map<Year, Integer> classSizes = new HashMap<>();
  students.stream().forEach(s ->
      classSizes.compute(
          s.getGraduationYear(),
          (k, v) -> (v == null) ? 1 : 1 + v));
  return classSizes;
}
```

A good test to figure out if a variable is effectively final is to add the final keyword to it. If the code still compiles, that variable is effectively final!

In the example, the `classSizes` variable is effectively final because the value of the variable itself does not change after it's initialized. Remember that in Java, objects are passed by reference. Even though the `HashMap` changes, the variable's value is the `HashMap`'s location in memory, and that location never changes.

**QUESTION 1 OF 3**

What is true of effectively final variables? (B, D)

* The variable has the `final` keyword in front of it.
* The value of the variable is never changed after it's first initialized.
* The variable has no effect because it is not used inside of any lambdas.
* If you add the final keyword to the variable, the code will still compile.
* The variables that hold `primitive` types cannot be effectively final.

{{< hint info >}}
Right! An effectively final variable's value never changes after initialization. You can tell a variable is effectively final if the code still compiles after you add the final keyword to that variable (which makes the variable explicitly final).
{{< /hint >}}

**QUESTION 2 OF 3**

```java
void printResult(List<String> input, StringWriter output) {
 Map<Integer, String> bySize = new HashMap<>();
 input.stream().forEach(
    (String s) -> bySize.put(s.length(), s));
 output.write(generateSummary(bySize));
}
```

Which variable(s) are captured in the lambda? (C)

* input
* output
* bySize
* s

{{< hint info >}}
Right! The `bySize` variable is initialized outside of the lambda, and then captured for use inside the lambda.
{{< /hint >}}

**QUESTION 3 OF 3**

```java
List<Runnable> runnables = new ArrayList<>(10);
for (int i = 0; i < 10; i++) {
  runnables.add(() -> System.out.println(i));
}
```

In the code snippet above, a lambda captures the variable `i`. Is `i` effectively final? (No)


{{< hint info >}}
Correct, this code will not compile because `i` is not effectively final. Even though the value of `i` does not change inside the lambda, the value changes (`i++`) each time the loop iterates.

One way to get around this would be to use an `IntStream`:

```java
List<Runnable> runnables = IntStream.range(1, 10).map(i -> () -> System.out.println(i)).collect(Collectors.toList());
```
{{< /hint >}}

### Method References

In this section, you will learn to identify when to use method references instead of lambdas.

{{< youtube nGjLDnKIbzo >}}

**What is a Method Reference?**

A **method reference** is a short lambda expression that refers to a method that is already named.

If a method with the right parameters and return values is already defined, you can use that instead of writing a new lambda. If this sounds confusing, don't worry — the next code demo should demonstrate how simple method references are to use.

**When to Use Method References**

Generally speaking, if a method is already defined that you can use, you should use a method reference instead of writing a brand new lambda. It's usually a good idea in software development to not write new code if there's already existing code that does the same thing you're trying to do!

Method references cannot capture surrounding variables, though. If you find yourself in this situation, you should use a custom lambda instead.

**Example**

We can take the original lambda expression demo and simplify it using a method reference to `String::isBlank`:

```java
import java.util.List;
import java.util.function.Predicate;

public final class LambdasMain {

  /**
   * Returns the number of strings that match a given condition.
   *
   * @param input the strings that should be tested.
   * @param condition the condition that strings should be tested against.
   * @return the number of strings in the input that match the condition.
   */
  public static long countMatchingStrings(List<String> input, Predicate<String> condition) {
    return input.stream().filter(condition).count();
  }

  public static void main(String[] args) {

    List<String> input = List.of("hello", "\t   ", "world", "", "\t", " ", "goodbye", "  ");

    long numberOfWhitespaceStrings = countMatchingStrings(input, String::isBlank);

    System.out.println(numberOfWhitespaceStrings + " whitespace strings");
  }
}
```

Notice how the method reference uses less code, and it's a little easier to read.

**QUESTION 1 OF 3**

Where can you use method references? (B)

* Outside classes.
* Anywhere you can use a lambda expression.
* In`for` loops.

**QUESTION 2 OF 3**

Considering that `s` is a `String`, what would be the equivalent method reference to the following lambda expression? (C)

`s -> s.toUpperCase()`

* `String->toUpperCase`
* `String::toUpperCase()`
* `String::toUpperCase`
* `s:toUpperCase`

**QUESTION 3 OF 3**

Why should you use a method reference instead of defining your own lambda? (B, D)

* You need to capture a variable.
* There is already a method defined that does what you want.
* Because method references support better type inference.
* When the a method reference results in better code readability.

### The Stream API

In this section, you will learn to:

- Compare "functional programming" and "imperative programming" styles
- Define what a Java Stream is and what it does
- Identify common intermediate and terminal stream operations

{{< youtube dZUZxbkQIic >}}

**What is a Stream?**

A `stream` is a sequence of elements.

Streams are useful because they allow us to process collection, one element at a time. They can process elements in many ways, such as (but not limited to) filtering or transforming elements, sorting elements, or computing statistics such as the sum or average.

**Stream Pipelines**

[stream pipelines](/images/stream_pipelines.png)

You Can Apply Many Intermediate Operations, But Only One Terminal Operation, To a Stream.

A stream pipeline consists of creating a stream, calling intermediate operations on the stream, and then terminating the stream using a terminal operation.

- Streams are *single-use*. Once you do an operation on a `Stream`, you cannot to any more operations on that same stream. This means intermediate operations always return a brand new `Stream`, never the original.

- Streams are `lazily evaluated`. No computation happens until the very end, when the terminal operation is called.

**Example**

```java
void printScores(List<Student> students) {
 return students.stream()
     .filter(Objects::nonNull)
     .mapToInt(Student::getScore)
     .forEach(System.out::println);
}
```

First, the `stream()` method creates a stream from the students list.

This stream pipeline has two intermediate methods: the `filter()` method removes the elements of the stream that are `null`, and `mapToInt()` transforms each student into an int. Notice that each of these methods returns another Stream: `filter()` returns a `Stream<Student>`, and `mapToInt()` returns an `IntStream`.

Finally, the terminal operation `max()` computes the maximum value in the `IntStream`. This terminal method actually returns an `OptionalInt` instead of an `int`. If the students parameter is empty or contains only null elements, it's possible the final stream will be empty. In this case, we need to tell the program to return a default value of 0.

**QUESTION 1 OF 3**

What is the correct order of a Stream Pipeline?

Stream creation -> Zero or more intermediate operations -> One terminal operation

**QUESTION 2 OF 3**

What is the terminal operator in the next code? (C)

```java
Stream.of("hello", "world")
     .map(String::toUpperCase)
     .collect(Collectors.joining(" ", "", "!"));
```

* `Stream.of("hello", "world")`
* `.map(String::toUpperCase)`
* `.collect(Collectors.joining(" ", "", "!"))`

{{< hint info >}}
Correct! `.collect(..)` repackages the elements of the stream into some data structure or apply additional logic to them. In this case, it's joining the `String` elements of the stream to create a new `String`.
{{< /hint >}}

**QUESTION 3 OF 3**

What does the following code print? (A)

```java
Stream.of(1, 2, 3)
    .sorted(Comparator.reverseOrder())
    .peek(System.out::print);
```

* nothing
* `123`
* `321`
* `312`

{{< hint info >}}
Right! Streams are lazily evaluated, meaning no computation happens until the terminal operator is called.
{{< /hint >}}
